解释器模式:
        定义语言的文法，并且建立一个解释器来解释该语言中的句子。它属于类的行为模式。这里的语言意思是使用规定格式和语法的代码。

应用环境：
        如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。而且当文法简单、效率不是关键问题的时候效果最好。

抽象表达式角色(AbstractExpression):
        声明一个抽象的解释操作,这个接口为所有具体表达式角色都要实现的.

终结符表达式角色(TerminalExpression):
         实现与文法中的元素相关联的解释操作,通常一个解释器模式中只有一个终结符表达式,但有多个实例对应不同的终结符.终结符就是语言中用到的基本元素,一般不能再被分解,
         如: x -> xa, 这里a是终结符，因为没有别的规则可以把a变成别的符号，不过x可以变成别的符号，所以x是非终结符.

非终结符表达式角色(NonterminalExpression):
        文法中的每条规则对应于一个非终结表达式, 非终结表达式根据逻辑的复杂程度而增加,原则上每个文法规则都对应一个非终结符表达式.

环境角色(Context):
        包含解释器之外的一些全局信息.

优点：
        解释器是一个简单语法分析工具，它最显著的优点就是扩展性，修改语法规则只要修改相应的非终结符表达式就可以了，若扩展语法，则只要增加非终结符类就可以了。

缺点：
        解释器模式会引起类膨胀，每个语法都要产生一个非终结符表达式，语法规则比较复杂时，可能产生大量的类文件，难以维护。
        解释器模式采用递归调用方法，它导致调试非常复杂。
        解释器由于使用了大量的循环和递归，所以当用于解析复杂、冗长的语法时，效率是难以忍受的

注意事项：
        尽量不要在重要模块中使用解释器模式，因为维护困难。在项目中，可以使用shell,JRuby,Groovy等脚本语言来代替解释器模式。

参考：
    http://www.cnblogs.com/itTeacher/archive/2012/12/12/2814437.html