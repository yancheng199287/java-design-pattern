迭代器（Iterator）模式:
        又叫做游标（Cursor）模式。GOF给出的定义为：提供一种方法访问一个容器（container）对象中各个元素，而又不需暴露该对象的内部细节。

在面向对象的软件设计中，我们经常会遇到一类集合对象，这类集合对象的内部结构可能有着各种各样的实现，但是归结起来，无非有两点是需要我们去关心的：一是集合内部的数据存储结构，二是遍历集合内部的数据。
面向对象设计原则中有一条是类的单一职责原则，所以我们要尽可能的去分解这些职责，用不同的类去承担不同的职责。Iterator模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，
这样既可以做到不暴露集合的内部结构，又可让外部代码透明的访问集合内部的数据。
1.通俗的来说，就是，别人可能要用到我们的容器元素，但是我只想让他用元素，不想让他知道容器是怎么样的。也就是最基本的，访问各个元素而不暴露容器内部细节。
2.我们有可能以一种以上的方式遍历容器元素
3.同时对容器元素进行多次遍历。因为迭代器会保存当前的遍历状态，所以可以通过迭代器模式来达到这种需求。

意图:
        提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。

由下面四个角色：
　　1) 迭代器角色（Iterator）：迭代器角色负责定义访问和遍历元素的接口。
　　2) 具体迭代器角色（Concrete Iterator）：具体迭代器角色要实现迭代器接口，并要记录遍历中的当前位置。
　　3) 容器角色（Container）：容器角色负责提供创建具体迭代器角色的接口。
　　4) 具体容器角色（Concrete Container）：具体容器角色实现创建具体迭代器角色的接口——这个具体迭代器角色于该容器的结构相关。

效果及实现要点

       迭代抽象：访问一个聚合对象的内容而无需暴露它的内部表示。
       迭代多态：为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作。
       迭代器的健壮性考虑：遍历的同时更改迭代器所在的集合结构，会导致问题。

总结:
    Iterator模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明的访问集合内部的数据。

迭代器模式的作用：
        它支持以不同的方式遍历一个聚合对象 ： 复杂的聚合可用多种方式进行遍历。迭代器模式使得改变遍历算法变得很容易 : 仅需用一个不同的迭代器的实例代替原先的实例即可。你也可以自己定义迭代器的子类以支持新的遍历。
         迭代器简化了聚合的接口 有了迭代器的遍历接口，聚合本身就不再需要类似的遍历接口了。这样就简化了聚合的接口。
        在同一个聚合上可以有多个遍历 每个迭代器保持它自己的遍历状态。因此你可以同时进行多个遍历。
        在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码，满足“开闭原则”的要求。

迭代器模式的缺点:
       由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。


适用情况:
    　　支持以不同的方式遍历一个容器角色。根据实现方式的不同，效果上会有差别。
    　　简化了容器的接口。但是在java Collection中为了提高可扩展性，容器还是提供了遍历的接口。
    　　对同一个容器对象，可以同时进行多个遍历。因为遍历状态是保存在每一个迭代器对象中的。
    　　访问一个容器对象的内容而无需暴露它的内部表示。
    　　支持对容器对象的多种遍历。
    　　为遍历不同的容器结构提供一个统一的接口（多态迭代）。